#!/usr/bin/env ruby

$:.unshift "lib" # ensure that any local libs are included in the search path

%w{
irb/completion
pp
breakpoint
pathname
}.each do |lib|
  begin
    require lib
  rescue LoadError => e
    puts e
  end
end

begin
  Wirble.init(:init_colors => true) if require "wirble"
rescue LoadError => e
  puts e
end

#IRB.conf[:PROMPT][:SPARSE] = 'abc'


IRB.conf[:PROMPT][:SPARSE] = {
  :PROMPT_I => "",
  :PROMPT_S => "",
  :PROMPT_C => "",
  :RETURN  =>  " # => %s\n"
}
IRB.conf[:PROMPT_MODE] = :SPARSE

IRB.conf[:AUTO_INDENT] = true
IRB.conf[:EVAL_HISTORY] = 1000 
IRB.conf[:SAVE_HISTORY] = 100


# load local environment
# Â¡this is a security risk!
def refresh
  # load local .irbrc files
  d = Pathname.new(Dir.pwd).realpath
  h = Pathname.new(ENV['HOME']).realpath
  load ".irbrc" if File.file? ".irbrc" and d != h
  files = `find -name '*.rb' -type f -print0`.split("\000")
  files.each{|f| load(f) }
  puts ' ' + banner(78, 'reloaded')
  files.each{|f| puts display_pathname(72, 2, Pathname.new(f).realpath.to_s) }
  nil
end

def display_pathname(w, i, s, r = "\n")
  indent = ' ' * (2 * i)
  if ind = s.index('/')
    len = r.length - r.rindex("\n") + ind
    display_pathname( w, i, s[(ind + 1)..-1],
                      r + ( len < w ? '' : indent + "\n" ) + s[0..ind] )
  else
    r.sub(/^\n/, ' ' * i).gsub(indent + "\n", "\n" + indent) + s
  end
end

def banner(w, s)
  a = /^[[:space:]]+/.match(s.center(w))
  b = /[[:space:]]+$/.match(a.post_match)
  [ a[0], b[0] ].collect do |s|
    '=' * (s.length - 1)
  end.join(' ' + b.pre_match + ' ')
end

def ri(arg)
  puts `ri #{arg}`
end

refresh

