set background=dark
set autoindent
set ruler
set showcmd
set incsearch
set autowriteall
set autoread
set foldminlines=1
set shiftwidth=2
set softtabstop=2
set expandtab
set textwidth=78 wrap
set nohlsearch
set foldexpr=indent(v:lnum)
set foldmethod=expr

" I hate backups!
set nobackup
set nowritebackup
set noswapfile

syntax on

" begin freebsd needs
set backspace=indent,eol,start
" end freebsd needs


function! haskell:module()
  let s = expand('%:.:r:gs?/?.?')
  call append(".", "module " . s . " where")
endfunction

function! haskell:align()
python << PYTHON
import vim
import re
cl                           =  vim.current.line
width                        =  int(vim.eval("&tw"))
if width is 78:
    fw                       =  32 - 5
    aw                       =  48 - 2
elif width is 64:
    fw                       =  25 - 5
    aw                       =  39
else:
    fw                       =  32 - 5
    aw                       =  48 - 2
m                            =  re.compile(r" (=|::) ").search(cl)
if not m:
  m                          =  re.compile(r" (<-|->) ").search(cl)
if m:
    fore                     =  re.compile(r"\s+$").sub('', cl[:m.start()])
    aft                      =  re.compile(r"^\s+").sub('', cl[m.end():])
    all_spaces               =  re.compile(r"^\s*$").search(fore)
    if len(fore) <= fw and len(aft) <= aw and not len(fore) is 0:
        spaced_out           =  m.group().rjust(4).ljust(5)
        formatted            =  fore.ljust(fw) + spaced_out + aft
        vim.current.line     =  formatted
PYTHON
endfunction

function! haskell:align_all()
  let a                      =  line(".")
  let b                      =  col(".")
  % call haskell:align()
  call cursor(a, b)
endfunction

function! haskell:comment_horizontal_rule(which)
  let text                   =  system("yes ' -' | sed '38 q' | tr -d '\n'")
  if a:which == "begin"
    call append(".", "{-" . text)
  else
    call append(".", text . " -}")
  endif
endfunction

function! haskell:comment_haddock()
  call append(".", " -}")
  call append(".", "{-| ")
  normal 1j
  normal 5|
endfunction

function! haskell:comment_block()
  call haskell:comment_horizontal_rule("end")
  call append(".", "  ")
  call haskell:comment_horizontal_rule("begin")
  normal 2j
  normal 3|
endfunction

command! -nargs=+ -complete=custom,haskell:complete HS
\ :silent! call haskell:dispatch("<args>")<CR>

function! haskell:complete(A,C,P)
  return join(keys(g:HS), "\n")
endfunction
 
function! haskell:dispatch(which)
  call g:HS[a:which]()
endfunction

let HS =
\ { "align all" : function("haskell:align_all")
\ , "haddock comment block" : function("haskell:comment_haddock")
\ , "module header" : function("haskell:module")
\ , "block comment" : function("haskell:comment_block")
\ }


function! cabal:align()
  let matches = matchlist(getline("."), '\v(^.+):( +)(.+$)')
  let diff = 18 - strlen(matches[1])
  if diff > 0 
    call setline(".", matches[1] . repeat(" ", diff) . ": " . matches[3])
  endif
endfunction

function! cabal:align_all()
  let a                      =  line(".")
  let b                      =  col(".")
  % call cabal:align()
  call cursor(a, b)
endfunction

command! -nargs=+ -complete=custom,cabal:complete CABAL
\ :silent! call cabal:dispatch("<args>")<CR>

function! cabal:complete(A,C,P)
  return join(keys(g:CABAL), "\n")
endfunction
 
function! cabal:dispatch(which)
  call g:CABAL[a:which]()
endfunction

let CABAL =
\ { "align all" : function("cabal:align_all")
\ }


runtime macros/justify.vim
command Just :call Justify(&tw)<CR>

command TeXalign :silent! call tex:align()<CR> 
function! tex:align()
python << PYTHON
import vim
import re
cl                           =  vim.current.line
width                        =  int(vim.eval("&tw"))
m = re.compile(r"\\([^{]+)\{[ ]*(.*[^ ])[ ]*\}").search(cl)
if m:
    (command, content)       =  m.groups()
    spaced                   =  content.rjust(width - 3 - len(command))
    vim.current.line         =  "\\" + command + "{" + spaced + " }"
PYTHON
endfunction

function! readme:general_header(underline_char)
  let matches = matchlist(getline("."), '\v[\t ]*(.+)([^\t ])[\t ]*$')
  let width = eval("&tw")
  let s = matches[1] . matches[2]
  let padding = width - strlen(s)
  call setline(".", "")
  normal o
  call setline(".", repeat(" ", padding) . s)
  normal o
  call setline(".", "   " . repeat(a:underline_char, width - 2))
  normal o
  call setline(".", "")
  normal 2o
  normal 2k 
endfunction

function! readme:header()
  call readme:general_header("-")
endfunction

command! -nargs=+ -complete=custom,readme:complete README
\ :silent! call readme:dispatch("<args>")<CR>

function! readme:complete(A,C,P)
  return join(keys(g:README), "\n")
endfunction
 
function! readme:dispatch(which)
  call g:README[a:which]()
endfunction

let README =
\ { "header" : function("readme:header")
\ }


" Delete date and such at the top of email replies.
nnoremap ck :silent! . ! sed -r 's/([> ]*).+, ([^,]+)$/\1\2/'<CR>

function! BNFAlign()
python << PYTHON
import vim
import re
cl                           =  vim.current.line
width                        =  int(vim.eval("&tw"))
if width is 78:
    fw                       =  25 - 6
    aw                       =  55 - 2
elif width is 64:
    fw                       =  25 - 6
    aw                       =  39
else:
    fw                       =  25 - 6
    aw                       =  48 - 2
m                            =  re.compile(r" ::= ").search(cl)
if m:
    fore                     =  re.compile(r"\s+$").sub('', cl[:m.start()])
    aft                      =  re.compile(r"^\s+").sub('', cl[m.end():])
    all_spaces               =  re.compile(r"^\s*$").search(fore)
    if len(fore) <= fw and len(aft) <= aw and not len(fore) is 0:
        formatted            =  fore.ljust(fw) + ' ::=  ' + aft
        vim.current.line     =  formatted
PYTHON
endfunction
function! BNFAlignAll()
  let a                      =  line(".")
  let b                      =  col(".")
  % call BNFAlign()
  if cursor(a, b)
  endif
endfunction
nnoremap bal :call BNFAlignAll() <CR>

filetype plugin indent on

autocmd BufRead *.messagebody setlocal filetype=messagebody
autocmd BufRead *.wiki setlocal filetype=wikipedia
autocmd BufRead *.hsc setlocal filetype=haskell

autocmd FileType ldif setlocal list
autocmd FileType messagebody setlocal textwidth=64 wrap
autocmd FileType mkd setlocal textwidth=78 wrap


" wikipedia is an annoying format
" i need to figure out some 1337 h4x for it
autocmd FileType wikipedia setlocal textwidth=78

if has("autocmd") && exists("+omnifunc")
	autocmd Filetype *
	\	if &omnifunc == "" |
	\		setlocal omnifunc=syntaxcomplete#Complete |
	\	endif
endif

" au FileType c setlocal tabstop=8 shiftwidth=8 noexpandtab
au FileType python setlocal tabstop=4 shiftwidth=4 expandtab

augroup mkd
  autocmd BufRead *.mkd  set ai formatoptions=tcroqn2 comments=n:>
augroup END

" annoying initial highlights removed
nohlsearch

